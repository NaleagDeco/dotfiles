# -*- mode: org; coding: utf-8; -*-
* Gaelan's Emacs Config
  This is my emacs config; there are many like it, but this one is mine.
** Preamble
*** File header
    There are little things I can do to make my life easier working with the tangled file.

    For one thing, I wil definitely want to enable lexical binding.
    For another thing, I can set the file to be opened in read-only mode in case I mistakenly try to edit the generated elisp file rather than this org file.
    #+BEGIN_SRC emacs-lisp :tangle yes
      ;;; init.el --- Gaelan's Emacs config -*- lexical-binding: t; eval: (view-mode 1) -*-
    #+END_SRC
** Initialization
   This is low-level stuff that sets up my emacs environment. It's usually not config but
   tweaking the environment to support my configuration.
*** Version Sentinal
    I am not sure if this config will work with older versions of emacs, so I'll abort if the running version of emacs is older than a known version.
 #+BEGIN_SRC emacs-lisp :tangle yes
   (let ((minver "26.1"))
     (when (version< emacs-version minver)
       (error "Your Emacs is too old -- this config requires v%s or higher" minver)))
 #+END_SRC
*** Garbage Collection threshold tweak
    I saw a config where the author tweaked garbage collection thresholds for speed during initialization, presuambly to minimize GC overhead at startup.
    When emacs has finished initalizing, it runs a hook we've set up to restore a more aggressive threshold.
    I have no idea if this is a good idea or not, but for now I will trust them.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (let ((normal-gc-cons-threshold (* 20 1024 1024))
	    (init-gc-cons-threshold (* 128 1024 1024)))
	(setq gc-cons-threshold init-gc-cons-threshold)
	(add-hook 'emacs-startup-hook
		  (lambda () (setq gc-cons-threshold normal-gc-cons-threshold))))
    #+END_SRC
    
*** Set location of custom file
    Emacs by default manages some forms for variables and faces and places them at the end of =init.el=. Since my =init.el= is generated, this would be difficult to manage.
    I can tell Emacs to use a different location for these, which will not be checked into source control or regenerated and Emacs can manage it to its heart's content.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    #+END_SRC
*** Who am I?
    My name and email will be used by things like git and email plugins and so on.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq user-full-name "Gaelan D'costa"
	    user-mail-address "gdcosta@gmail.com")
    #+END_SRC
*** Enable Common Lisp language features
    We'll need to load common-lisp functionality, but since we're only using macros, we can restrict it to the compliation step to monimize runtime bloat.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (eval-when-compile
	(require 'cl-lib))
    #+END_SRC
** Some helpful constants
    There are some constants I will refer to often; this is a good place to put them.
    These will often be things like quickly getting the operating system and user-defined directories and such.
 #+BEGIN_SRC emacs-lisp :tangle yes
   (defconst gaelan/*is-osx* (eq system-type 'darwin)
     "Is this operating system OSX?")
   (defconst gaelan/*is-linux* (eq system-type 'gnu/linux)
     "Is this operating system Linux?")
 #+END_SRC
** Package Management
   From this point out, we're likely going to be installing and configuration packages.
   The first thing we should do is configure our packaging system

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'package)
   #+END_SRC
*** Enable package sources
    By default, emacs' package manager only grabs packages from GNU's ELPA package library, which has a very tiny selection of packages.
    We are going to add the following additional reposities:
    - melpa-stable :: Stable versions of almost every commonly-used package
    - melpa :: Unstable versions of almost every commonly-used package
    - org :: The repository for org mode, my favourite emacs package :)

    My understanding is that the order of repos =package-archives= does not matter, if this because a problem (i.e. the wrong versions of packages are being pulled because they exist in multiple archives) the solution is apparently to set values in =package-archive-priorities=

    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-to-list 'package-archives
		   '("melpa-stable" . "https://stable.melpa.org/packages/"))
      (add-to-list 'package-archives
		   '("melpa" . "https://melpa.org/packages/"))
      (add-to-list 'package-archives
		   '("org" . "https://orgmode.org/elpa/"))
    #+END_SRC
*** Initialize the package subsystem
    #+BEGIN_SRC emacs-lisp :tangle yes
      (package-initialize)
    #+END_SRC
*** use-package, an easier way to manage package configuration
    While ELPA is still Emacs' package management system, it is a pretty manual process.
    Traditionally, one has to manually download the package, manually require the package in one's config, and then customize it by setting the appropriate variables and running the appropriate functions.

    This is messy if one wants to always ensure that packages are installed, or if there is a logical ordering to packages (for example a base package must be loaded and configured before additional packages extend it.
    In addition, there is a lot of repeated boilerplate around things like associating modes with file extensions or configuring key bindings for these packages.

    John Wiegley has written a nice emacs plugin to manage these via a macro, which makes reading one's intended configuration for each package a lot more compact and easier to comprehend.

    Because it is a macro, we only need to require the package when compiling the configuration file.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (eval-when-compile
	(require 'use-package))
    #+END_SRC
*** Always download packages, if required
    By default, use-package does not download emacs packages if they are missing.

    I would like that to happen rather than having to install them all manually myself

    #+BEGIN_SRC emacs-lisp :tangle yes
      (require 'use-package-ensure)
      (setq use-package-always-ensure t)
    #+END_SRC
*** Automatically update packages
    Emacs doesn't update packages automatically. There is a package which enables this.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package auto-package-update
	:config
	(setq auto-package-update-delete-old-versions t)
	(setq auto-package-update-hide-results t)
	(auto-package-update-maybe))
    #+END_SRC
**** Diminish 
    Having the full name of every package displayed would clog our status line; there is a package that will appreviate the name of well-known packages to a couple of characters.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package diminish
	:config (require 'diminish))
    #+END_SRC
**** Bind-key
     Since we're going to be using the =:bind= keyword to configure keybindings, we require the =bind-key= package
     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package bind-key
	 :config (require 'bind-key))
     #+END_SRC
** Editor Workflow enhancements
*** Project Management
    =projectile= is a package that adds a software development workflow to collections of files.

    #+begin_src emacs-lisp :tangle yes
      (use-package projectile
	:pin melpa-stable
	:config
	(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
	(projectile-mode +1))
    #+end_src
**** Helm support
     Use helm in projectile commands
     #+begin_src emacs-lisp :tangle yes
       (use-package helm-projectile
	 :requires helm
	 :pin melpa-stable
	 :config
	 (helm-projectile-on))
     #+end_src
**** Ripgrep support
     Ripgrep is my preferred choice in the "better than grep" software category
     #+begin_src emacs-lisp :tangle yes
       (use-package projectile-ripgrep
	 :pin melpa-stable
	 :after projectile)
     #+end_src
*** Error/Syntax checking
    We use =flycheck= for things like on-the-fly syntax checking, linting, dynamic runtime analysis, etc...
    #+begin_src emacs-lisp :tangle yes
      (use-package flycheck
	:pin melpa-stable
	:hook (after-init-hook . global-flycheck-mode))
    #+end_src
*** Snippet Manager
    It's annoying to type the same things over and over. =yasnippet= is a tool that expands full templates from short snippets.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package yasnippet-snippets)
      (use-package yasnippet
	:after yasnippet-snippets
	:config
	(yas-global-mode 1))
    #+END_SRC
** Software Development
*** Git
    =magit= is a super awesome git package
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package magit
	;; I should have a keybinding that displays magit-status from anywhere
	:bind (("C-x g" . magit-status))
	:config
	;; Enable pseudo-worktree for uncommitted files.
	(require 'magit-wip)
	(magit-wip-mode))
    #+END_SRC
** Window Management
   I love Emacs so much, I use it as my window manager :)
*** Window title hook
    By default, all X Window buffers have the title of =*EXWM*=. I want them to have the supplied window name of the application they contain, and I can perform that via a hook.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun gaelan/exwm-update-title-hook ()
	"EXWM hook for renaming buffer names to their associated X window title."
	(exwm-workspace-rename-buffer exwm-title))

      (defun gaelan/exwm-update-class-hook ()
	"EXWM hook for renaming buffer names to their associated X window class."
	(exwm-workspace-rename-buffer exwm-class-name))
    #+END_SRC
*** Monitor change hook
    This hook invokes =xrandr= and, based on the monitors in my house and where they connect to my laptop, and reconfigures what monitors are enabled or disabled for X Windows.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun gaelan/exwm-randr-screen-change-hook ()
	"Hook for updating X screens when monitors plugged in."
	;; Start by enumerating over which screens are connected and disconnected
	(let ((xrandr-output-regexp "\n\\([^ ]+\\) \\(dis\\)?connected ")
	     output-connected
	     output-disconnected)
	 (with-temp-buffer
	   (call-process "xrandr" nil t nil)
	   (goto-char (point-min))
	   (while (re-search-forward xrandr-output-regexp nil 'noerror)
	     (if (null (match-string 2))
		 (add-to-list 'output-connected (match-string 1))
	       (add-to-list 'output-disconnected (match-string 1))))
	   ;; disable all screens that are marked as disabled.
	   (dolist (output output-disconnected)
	     (call-process "xrandr" nil nil nil "--output" output "--off"))
	   (dolist (output output-connected)
	     (cond ((string= output "DP-1-1")
		    ;; When docked, this is my main monitor
		    (call-process "xrandr" nil nil nil
				  "--output" output "--primary" "--auto"))
		   ((string= output "DP-1-2")
		    ;; My second monitor is in portrait mode
		    (call-process "xrandr" nil nil nil
				  "--output" output "--auto" "--rotate" "left" "--right-of" "DP-1-1"))
		   ((string= output "eDP-1")
		    (if (= (length output-connected) 1)
			;; If this is the only connected screen, mark it as the primary one.
			(call-process "xrandr" nil nil nil
				      "--output" output "--primary" "--auto")
		      ;; If it isn't the only monitor, my laptop is most likely in
		      ;; clamshell mode.
		      (call-process "xrandr" nil nil nil
				    "--output" output "--off"))))))))
    #+END_SRC
*** Enable and configure EXWM
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package exwm
	:init
	;; Set some global window management bindings
	(setq exwm-input-global-keys
	      `(
		;; 's-r': Reset to (line-mode).
		([?\s-r] . exwm-reset)
		;; 's-w': Switch workspace.
		([?\s-w] . exwm-workspace-switch)
		;; 's-p': Launch application
		([?\s-p] . (lambda (command)
			     (interactive (list (read-shell-command "$ ")))
			     (start-process-shell-command command nil command)))
		;; 's-<N>': Switch to certain workspace.
		,@(mapcar (lambda (i)
			    `(,(kbd (format "s-%d" i)) .
			      (lambda ()
				(interactive)
				(exwm-workspace-switch-create ,i))))
			  (number-sequence 0 9))))
	;; translate emacs keybindings into CUA-like ones for most apps, since most
	;; apps don't observe emacs kebindings and we would like a uniform experience.
	(setq exwm-input-simulation-keys
	      '(;; movement
		([?\C-b] . [left])
		([?\M-b] . [C-left])
		([?\C-f] . [right])
		([?\M-f] . [C-right])
		([?\C-p] . [up])
		([?\C-n] . [down])
		([?\C-a] . [home])
		([?\C-e] . [end])
		([?\M-v] . [prior])
		([?\C-v] . [next])
		([?\C-d] . [delete])
		([?\C-k] . [S-end delete])
		;; cut/paste
		([?\C-w] . [?\C-x])
		([?\M-w] . [?\C-c])
		([?\C-y] . [?\C-v])
		;; search
		([?\C-s] . [?\C-f])))
	;; Configure workspace 1 to show up by default on my portrait monitor.
	;; By default, workspaces show up on the first, default, active monitor.
	(setq exwm-randr-workspace-output-plist
	      '(1 "DP-1-2"))
	:config
	(add-hook 'exwm-update-class-hook
		  'gaelan/exwm-update-class-hook)
	(add-hook 'exwm-update-title-hook
		  'gaelan/exwm-update-title-hook)

	;; Enable multi-monitor support for EXWM
	(require 'exwm-randr)
	(add-hook 'exwm-randr-screen-change-hook
		  'gaelan/exwm-randr-screen-change-hook)
	(exwm-randr-enable))
   #+END_SRC
*** Multimedia keys
    If Emacs is going to be our window manager, it only makes sense to have it handle things like multimedia keys on keyboards

    =desktop-environment-mode= is a package that automatically hooks up handlers for things like brightness, volume, wireless disable, etc...

    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package desktop-environment
	:config
	(desktop-environment-mode))
    #+END_SRC
